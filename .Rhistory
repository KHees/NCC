n_arm = 250,
d = 250*c(0:2),
period_blocks = 2,
mu0 = 0,
theta = rep(0.15, 3),
lambda = rep(0, 4),
sigma = 1,
trend = "stepwise_2")
timemachine_cont(data = data_stepwise_null, arm = 3)
MAP_rjags_cont(data = data_stepwise_null, arm = 3)
data_stepwise_alt <- datasim_cont(num_arms = 3,
n_arm = 250,
d = 250*c(0:2),
period_blocks = 2,
mu0 = 0,
theta = rep(0.25, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "stepwise_2")
timemachine_cont(data = data_stepwise_alt, arm = 3)
MAP_rjags_cont(data = data_stepwise_alt, arm = 3)
data_stepwise_null <- datasim_cont(num_arms = 3,
n_arm = 250,
d = 250*c(0:2),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "stepwise_2")
timemachine_cont(data = data_stepwise_null, arm = 3)
MAP_rjags_cont(data = data_stepwise_null, arm = 3)
data_stepwise_alt <- datasim_cont(num_arms = 3,
n_arm = 250,
d = 250*c(0:2),
period_blocks = 2,
mu0 = 0,
theta = rep(0.25, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "stepwise_2")
timemachine_cont(data = data_stepwise_alt, arm = 3)
MAP_rjags_cont(data = data_stepwise_alt, arm = 3)
data_linear_null <- datasim_cont(num_arms = 3,
n_arm = 250,
d = 250*c(0:2),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "linear")
timemachine_cont(data = data_linear_null, arm = 3)
MAP_rjags_cont(data = data_linear_null, arm = 3)
data_linear_alt <- datasim_cont(num_arms = 3,
n_arm = 250,
d = 250*c(0:2),
period_blocks = 2,
mu0 = 0,
theta = rep(0.25, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "linear")
timemachine_cont(data = data_linear_alt, arm = 3)
MAP_rjags_cont(data = data_linear_alt, arm = 3)
View(data_linear_alt)
View(data_stepwise_alt)
mod4=glmmTMB(y ~ trt+ar1(time + 0 |group), data=dat, REML=F) # A: mixed time AR(1)
summary(mod4)
mod5=fitme(y ~ 1 +trt+AR1(1|time), data=dat, method="ML") # B: mixed time AR(1)
summary(mod5)
mod6=fitme(y ~ trt+AR1(1|time), data=dat, method="ML") # B: mixed time AR(1)
summary(mod6)
all.equal(mod5, mod6)
identical(mod5, mod6)
?fitme
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
arm <- 3
data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
mod
res
pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], coef(res)[paste0("as.factor(treatment)", arm), "df"], lower.tail = FALSE)
coef(res)[paste0("as.factor(treatment)", arm), "t value"]
coef(res)
res$beta_table
res$beta_table[paste0("as.factor(treatment)", arm), "t value"]
res$beta_table[paste0("as.factor(treatment)", arm), "t-value"]
mod$dfs
mod$how
mod$APHLs
library(lmerTest)
mod <- lmer(response ~ as.factor(treatment) + (1 | period), data_new) # using lmerTest
res <- summary(mod)
coef(res)
get_any_IC(mod)
?get_any_IC
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
get_any_IC(mod)
mod$dfs
mod$fixef
res$beta_table[paste0("as.factor(treatment)", arm), "t-value"]
res <- summary(mod)
res$beta_table[paste0("as.factor(treatment)", arm), "t-value"]
res$beta_table
res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
res$REMLformula
res$family
res$beta_table
res$lambda_table
res$likelihoods
mod$APHLs
mod$X.pv
View(data)
mod$fixef
mod$eta
mod$muetablob
mod$data
mod$y
mod$prior.weights
mod$family
mod$ranFix
mod$CorrEst_and_RanFix
mod$corrPars
mod$spatial_terms
mod$warnings
mod$phi
mod$phi.object
data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.3, 4), sigma = 1, trend = "linear")
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
mod$phi
mod$phi.object
mod$residModel
mod$w.ranef
mod$HL
mod$fv
mod$rand.families
mod$ranef_info
ranef(mod)
mod <- lmer(response ~ as.factor(treatment) + (1 | period), data_new) # using lmerTest
ranef(mod)
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
mod$ZAlist
class(mod)
get_any_IC(mod)
mod1=lm(y ~ 1 + trt + time,data=dat) # time fixed
mod1$df.residual
mod1$df
mod <- lmer(response ~ as.factor(treatment) + (1 | period), data_new) # using lmerTest
res <- summary(mod)
coef(res)
mod
res
pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], coef(res)[paste0("as.factor(treatment)", arm), "df"], lower.tail = FALSE)
0.43630/2
summary(mod1)
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
get_any_IC(mod)
get_any_IC(mod)["effective df:", "value"]
a<-get_any_IC(mod)
a
get_any_IC(mod)["effective df:"]
names(a)
a$`effective df:`
a["effective df:"]
a["       effective df:"]
drop(a["       effective df:"])
get_any_IC(mod)["       effective df:"]
get_any_IC(mod)["       effective df:", "value"]
b<-a["       effective df:"]
b
# one-sided p-value
IC <- get_any_IC(mod)
eff_df <- IC["       effective df:"]
pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
p_val <- pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
mod
res
p_val
test <- glmmTMB(response() ~ as.factor(treatment) + ar1(period + 0 |group), data=data_new, REML=F)
test <- glmmTMB(response() ~ as.factor(treatment) + ar1(period + 0 |1), data=data_new, REML=F)
test <- glmmTMB(response ~ as.factor(treatment) + ar1(period + 0 |1), data=data_new, REML=F)
test
summary(test)
res
0.11662/2
data_new$group <- 1
View(data_new)
test <- glmmTMB(response ~ as.factor(treatment) + ar1(period + 0 |group), data=data_new, REML=F)
test <- glmmTMB(response ~ as.factor(treatment) + ar1(as.factor(period) + 0 |group), data=data_new, REML=F)
test
summary(test)
res
0.37624/2
p_val
# treatment effect
treat_effect <- res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
confint(mod)
mod
res
confint.HLfit(mod)
?confint.HLfit
confint.HLfit(mod, "X1")
confint.HLfit(mod, "treatment")
confint.HLfit(mod, "as.factor(treatment)")
class(mod)
confint.HLfit(mod, names(fixef.HLfit(mod)))
confint.HLfit(mod, "as.factor(treatment)3")
confint.HLfit(mod, paste0("as.factor(treatment)", arm))
confint.HLfit(mod, paste0("as.factor(treatment)", arm))[1]
confint.HLfit(mod, paste0("as.factor(treatment)", arm))
a<-confint.HLfit(mod, paste0("as.factor(treatment)", arm))
a$lowerfit
a$interval
a$interval[1]
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm))$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm))$interval[2]
lower_ci
upper_ci
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = ifelse(exists("lower_ci"), lower_ci, "not computed"),
upper_ci = ifelse(exists("upper_ci"), upper_ci, "not computed"),
reject_h0 = reject_h0))
mixmodel_cont <- function(data, arm, alpha=0.025, ci=FALSE, ...){
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
# fit linear mixed model
if(max_period==1){ # if only one period in the data, don't use period as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
}
} else {
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
# one-sided p-value
IC <- get_any_IC(mod)
eff_df <- IC["       effective df:"]
p_val <- pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm))$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm))$interval[2]
}
}
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = ifelse(exists("lower_ci"), lower_ci, "not computed"),
upper_ci = ifelse(exists("upper_ci"), upper_ci, "not computed"),
reject_h0 = reject_h0))
}
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.3, 4), sigma = 1, trend = "linear")
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
mixmodel_AR1_cont <- function(data, arm, alpha=0.025, ci=FALSE, ...){
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
# fit linear mixed model
if(max_period==1){ # if only one period in the data, don't use period as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
}
} else {
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
# one-sided p-value
IC <- get_any_IC(mod)
eff_df <- IC["       effective df:"]
p_val <- pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm))$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm))$interval[2]
}
}
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = ifelse(exists("lower_ci"), lower_ci, "not computed"),
upper_ci = ifelse(exists("upper_ci"), upper_ci, "not computed"),
reject_h0 = reject_h0))
}
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.3, 4), sigma = 1, trend = "linear")
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
a <- mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
a
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = F)$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = F)$interval[2]
mixmodel_AR1_cont <- function(data, arm, alpha=0.025, ci=FALSE, ...){
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
# fit linear mixed model
if(max_period==1){ # if only one period in the data, don't use period as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
}
} else {
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
# one-sided p-value
IC <- get_any_IC(mod)
eff_df <- IC["       effective df:"]
p_val <- pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = F)$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = F)$interval[2]
}
}
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = ifelse(exists("lower_ci"), lower_ci, "not computed"),
upper_ci = ifelse(exists("upper_ci"), upper_ci, "not computed"),
reject_h0 = reject_h0))
}
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod)
?summary.HLfit
mixmodel_AR1_cont <- function(data, arm, alpha=0.025, ci=FALSE, ...){
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
# fit linear mixed model
if(max_period==1){ # if only one period in the data, don't use period as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
}
} else {
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod, verbose = FALSE)
# one-sided p-value
IC <- get_any_IC(mod)
eff_df <- IC["       effective df:"]
p_val <- pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = FALSE)$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = FALSE)$interval[2]
}
}
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = ifelse(exists("lower_ci"), lower_ci, "not computed"),
upper_ci = ifelse(exists("upper_ci"), upper_ci, "not computed"),
reject_h0 = reject_h0))
}
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
?get_any_IC
mixmodel_AR1_cont <- function(data, arm, alpha=0.025, ci=FALSE, ...){
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
# fit linear mixed model
if(max_period==1){ # if only one period in the data, don't use period as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
}
} else {
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod, verbose = FALSE)
# one-sided p-value
IC <- get_any_IC(mod, verbose = FALSE)
eff_df <- IC["       effective df:"]
p_val <- pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = FALSE)$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = FALSE)$interval[2]
}
}
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = ifelse(exists("lower_ci"), lower_ci, "not computed"),
upper_ci = ifelse(exists("upper_ci"), upper_ci, "not computed"),
reject_h0 = reject_h0))
}
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
mixmodel_AR1_cont <- function(data, arm, alpha=0.025, ci=FALSE, ...){
max_period <- max(data[data$treatment==arm,]$period)
data_new <- data[data$period %in% c(1:max_period),]
# fit linear mixed model
if(max_period==1){ # if only one period in the data, don't use period as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
}
} else {
mod <- fitme(response ~ as.factor(treatment) + AR1(1 | period), data_new)
res <- summary(mod, verbose = FALSE)
# one-sided p-value
IC <- get_any_IC(mod, verbose = FALSE)
eff_df <- IC["       effective df:"]
p_val <- pt(res$beta_table[paste0("as.factor(treatment)", arm), "t-value"], eff_df, lower.tail = FALSE)
# treatment effect
treat_effect <- res$beta_table[paste0("as.factor(treatment)", arm), "Estimate"]
# confidence intervals
if (ci) {
lower_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = FALSE)$interval[1]
upper_ci <- confint.HLfit(mod, paste0("as.factor(treatment)", arm), verbose = FALSE)$interval[2]
}
}
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = ifelse(exists("lower_ci"), lower_ci, "not computed"),
upper_ci = ifelse(exists("upper_ci"), upper_ci, "not computed"),
reject_h0 = reject_h0))
}
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 0, 0),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
mixmodel_AR1_cont(data = trial_data, arm = 3, ci = TRUE)
# Copy in R folder the functions of the r package
setwd("C:/Users/pavla/Nextcloud/GitKraken/NCC")
devtools::document()
devtools::load_all()
# Copy in R folder the functions of the r package
setwd("C:/Users/pavla/Nextcloud/GitKraken/NCC")
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran=TRUE, manual = TRUE)
# Copy in R folder the functions of the r package
setwd("C:/Users/pavla/Nextcloud/GitKraken/NCC")
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran=TRUE, manual = TRUE)
devtools::build_manual(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL)
