lm.latex(model_death, addref = T, rowlabs = c("Heart valve: Bio", "Heart valve: TAVI"),
table.placement="H")
}
death_mod_tab <- function(data){
model_death <- coxph(Surv(Death_time, Death) ~ OP_typ + IndexOPalter + SEX + Herzinsuf_vor + Heart_attack_vor + Stroke_vor +
Diag_3_vor + Diag_7_vor + Diag_8_vor + Diag_9_vor + Diag_14_vor + Diag_15_vor + Diag_17_vor + Diag_25_vor, data = data)
lm.latex(model_death, addref = F, rowlabs = c("Heart valve: TAVI", "Age", "Sex: W",
"Heart failure", "Heart attack", "Stroke",
"Diabetes mellitus", "Adipositas", "Hypercholesterinämie und Hypertriglyceridämie", "Hyperurikämie und Gicht",
"ischämische, valvuläre, rhythmogene und sonstige Kardiopathien",
"Atherosklerose-Erkrankungen (u.a. pAVK)", "Lungenkrankheiten (v.a. COPD, Asthma)", "Nierenerkrankungen"),
table.placement="H")
}
model_death <- coxph(Surv(Death_time, Death) ~ OP_typ + IndexOPalter + SEX + Herzinsuf_vor + Heart_attack_vor + Stroke_vor +
Diag_3_vor + Diag_7_vor + Diag_8_vor + Diag_9_vor + Diag_14_vor + Diag_15_vor + Diag_17_vor + Diag_25_vor, data = Data_65)
summary(model_death)
tab_obs_events(var1 = Data$Death, var2 = Data$OP_typ, var1_name = "Death", caption = "Death: Observed events")
death_plot(Data)
death_mod_tab(Data)
tab_obs_events(var1 = Data_50$Death, var2 = Data_50$OP_typ, var1_name = "Death", caption = "Death: Observed events")
death_mod_tab(Data_50)
death_mod_tab(Data_50_65)
tab_obs_events(var1 = Data_50_65$Death, var2 = Data_50_65$OP_typ, var1_name = "Death", caption = "Death: Observed events")
herzinsuffizienz_plot <- function(data){
ci_herzinsuffizienz <- cuminc(ftime = data$CR_Herzinsuf_time,
fstatus = data$CR_Herzinsuf,
group = data$OP_typ,
cencode = 0)
p <- ggcompetingrisks(fit = ci_herzinsuffizienz, multiple_panels = F)
p$mapping <- aes(x = time, y = est, colour = group, linetype = event)
p +
scale_linetype_manual(name="Event:", values = 1:2, labels = c("Heart failure", "Death")) +
scale_color_manual(name="Heart valve:", values = viridis(3), labels = c("Bio", "TAVI")) +
ggtitle("") +
theme(axis.title.x = element_text(size = 11),
axis.title.y = element_text(size = 11),
axis.text.x = element_text(size = 11),
axis.text.y = element_text(size = 11)) +
coord_cartesian(xlim=c(0, 4000)) #+
#labs(x = "Time (years)") +
#scale_x_continuous(labels = rlang::as_function(~ round(.x/365, 2)), breaks = seq(0, 3650, by=365*2), limits = c(0, max(p$data$time)))
}
herzinsuffizienz_mod_tab_uni <- function(data){
fix_cov <- model.matrix(~ OP_typ,
data = data)[, -1]
model_herzinsuffizienz <- crr(ftime = data$CR_Herzinsuf_time, fstatus = data$CR_Herzinsuf, failcode=1, cencode=0, cov1 = fix_cov)
lm.latex(model_herzinsuffizienz, rowlabs = c("Heart valve: Bio", "Heart valve: TAVI"), addref = T, explanatory_vars = c("OP_typ"), data = data,
table.placement="H")
}
herzinsuffizienz_mod_tab <- function(data){
fix_cov <- model.matrix(~ OP_typ + IndexOPalter + SEX + Heart_attack_vor + Stroke_vor +
Diag_3_vor + Diag_7_vor + Diag_8_vor + Diag_9_vor + Diag_14_vor + Diag_15_vor + Diag_17_vor + Diag_25_vor,
data = data)[, -1]
model_herzinsuffizienz <- crr(ftime = data$CR_Herzinsuf_time, fstatus = data$CR_Herzinsuf, failcode=1, cencode=0, cov1 = fix_cov)
lm.latex(model_herzinsuffizienz, addref = F,
rowlabs = c("Heart valve: TAVI", "Age", "Sex: W",
"Heart attack", "Stroke",
"Diabetes mellitus", "Adipositas", "Hypercholesterinämie und Hypertriglyceridämie", "Hyperurikämie und Gicht",
"ischämische, valvuläre, rhythmogene und sonstige Kardiopathien",
"Atherosklerose-Erkrankungen (u.a. pAVK)", "Lungenkrankheiten (v.a. COPD, Asthma)", "Nierenerkrankungen"), explanatory_vars = c(), data = data,
table.placement="H")
}
tab_obs_events(var1 = Data[Data$Herzinsuf_vor==0,]$Herzinsuf_nach, var2 = Data[Data$Herzinsuf_vor==0,]$OP_typ, var1_name = "Heart failure", caption = "Heart failure after OP: Observed events")
tab_obs_events(var1 = Data_50[Data_50$Herzinsuf_vor==0,]$Herzinsuf_nach, var2 = Data_50[Data_50$Herzinsuf_vor==0,]$OP_typ, var1_name = "Heart failure", caption = "Heart failure after OP: Observed events")
#devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
library(NCC)
get_ss_matrix(num_arms = 3, n_arm = 3000, d = c(0,3000,7500))
sum(get_ss_matrix(num_arms = 3, n_arm = 3000, d = c(0,3000,7500)), na.rm=T)
15000/25
600/12
15000/250
60/12
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
mixmodel_cal_cont(trial_data, arm=2, unit_size=250)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2, unit_size=250)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2, unit_size=250)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2, unit_size=250)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2, unit_size=250)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2, unit_size=250)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cont(trial_data, arm=2)
get_ss_matrix(num_arms = 3, n_arm = 3000, d = c(0,3000,7500))
mixmodel_cal_cont(trial_data, arm=2, unit_size = 100)
sum(get_ss_matrix(num_arms = 3, n_arm = 3000, d = c(0,3000,7500)), na.rm = T)
15000/100
150/12
15000/250
60/15
fix_cal_cont(trial_data, arm=2, unit_size = 100)
fixmodel_cal_cont(trial_data, arm=2, unit_size = 100)
fixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
fixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
mixmodel_cal_cont(trial_data, arm=2)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
fixmodel_cal_cont(trial_data, arm=2, unit_size = 250)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
fixmodel_cal_cont(trial_data, arm=2, unit_size = 250)
fixmodel_cal_cont <- function(data, arm, alpha=0.025, unit_size=250){
data$cal_time <- rep(c(1:ceiling((nrow(data)/unit_size))), each=unit_size)[1:nrow(data)]
max_unit <- max(data[data$treatment==arm,]$cal_time)
data_new <- data[data$cal_time %in% c(1:max_unit),]
# fit linear model
if(max_unit==1){ # if only one calendar time unit in the data, don't use unit as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
} else {
mod <- lm(response ~ as.factor(treatment) + as.factor(cal_time), data_new)
}
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# metrics
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = lower_ci,
upper_ci = upper_ci,
reject_h0 = reject_h0))
}
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
fixmodel_cal_cont(data = trial_data, arm = 3)
View(trial_data)
devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
#devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
library(NCC)
#devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
library(NCC)
?fixmodel_cal_cont
?mixmodel_cal_cont
library(tidyverse)
32*0.7
32*0.9
32*0.9
# Copy in R folder the functions of the r package
setwd("C:/Users/pavla/Nextcloud/GitKraken/NCC")
# Install development version from GitHub
devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
# Run once to configure your package to use pkgdown
usethis::use_pkgdown()
# Run to build the website
pkgdown::build_site()
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
install.packages("RBesT")
devtools::document()
devtools::document()
library(RBesT)
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran=TRUE, manual = TRUE)
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran=TRUE, manual = TRUE)
library(NCC)
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "stepwise")
MAP_rjags_cont <- function(data, arm, alpha = 0.025, opt = 1,prior_prec_tau = 1, n.samples = 1000, n.chains = 4,
n.iter = 4000,n.adapt=1000,robustify=TRUE,weight=0.1){
if (opt %in% c(1,2) == FALSE) stop("Wrong parameter input. Parameter opt has to be 1 or 2")
# 1-alpha is here the decision boundary for the posterior probability,
# in case that one uses a non-informative/flat prior instead of a MAP prior, the type one error is equal to alpha
#Data preparation
##count number of patients for each treatment in each period
tab_count <- table(data$treatment,data$period)
## count number of groups and number of periods
number_of_groups <- dim(table(data$treatment,data$period))[1] # number of groups incl control
number_of_periods <- dim(table(data$treatment,data$period))[2] #total number of periods
## get start and end period of each treatment
treatment_start_period <- numeric(number_of_groups)
treatment_end_period <- numeric(number_of_groups)
for (i in 1:number_of_groups){
treatment_start_period[i] <- min(which(table(data$treatment,data$period)[i,] > 0))
treatment_end_period[i] <- max(which(table(data$treatment,data$period)[i,] > 0))
}
## get concurrent and non-concurrent controls of treatment = arm
cc <- data[data$treatment == 0 & data$period > treatment_start_period[arm + 1] - 1 & data$period < treatment_end_period[arm + 1] + 1, ]
ncc <- data[data$treatment == 0 & data$period < treatment_start_period[arm + 1], ]
if(opt==1){
ncc$period <- 0
}
## get patients treated with treatment=arm
t_treatment <- data[data$treatment == arm,]
## data for the model underlying for control data
ncc_control_data_jags <- list(
N_std = length(unique(ncc$period)),
y = sapply(unique(ncc$period), function(x) mean(ncc[ncc$period == x, ]$response)),
se = sapply(unique(ncc$period), function(x) sd(ncc[ncc$period == x, ]$response)/sqrt(length(ncc[ncc$period == x, ]$response))),
prior_prec_tau = prior_prec_tau
)
## get summary data of treatment group and concurrent controls
## get summary data of treatment group and concurrent controls
y.act <- mean(t_treatment$response)
n.act <- length(t_treatment$response)
y.act.se <-sd(t_treatment$response)/sqrt(n.act)
y.pbo <- mean(cc$response)
n.pbo <- length(cc$response)
y.pbo.se <- sd(cc$response)/sqrt(n.pbo)
model_text <- "model
{
for (i in 1:N_std) {
y[i] ~ dnorm(theta[i],se)
theta[i] ~ dnorm(mu,inv_tau2)
}
inv_tau2 <- pow(tau, -2)
tau ~ dnorm(0, prior_prec_tau)I(0,) # HN(scale = 1 / sqrt(prior_prec_tau)), I(0,) means censoring on positive values
mu  ~ dnorm(0, 0.001)
# prediction for theta in a new study
theta.pred ~ dnorm(mu, inv_tau2)
}"
fit <- jags.model(file = textConnection(model_text),
data = ncc_control_data_jags,
#inits = inits,
n.chains = n.chains,
n.adapt = n.adapt,
quiet = TRUE
)
# Draw samples from the above fitted MCMC model
help_mcmc_samples <- coda.samples(fit, "theta.pred ", n.iter = n.iter)
help_samples <- do.call(rbind.data.frame, help_mcmc_samples)[,1]
## Fit Beta mixture to MCMC samples
prior_control <- automixfit(help_samples,type="norm",Nc=3) # Nc=3: fixed number of mixture components, to speed the code up
if (robustify== TRUE) {
prior_control<-robustify(prior_control,weight=weight,mean=0,sigma=2)
}
#Create prior for treatment group
weak_prior_treatment <- mixnorm(c(1,0,1000), param = 'ms') # creates weak prior for the treatment group
#mixnorm creates normal mixture density, here with one component, mean 0 and sd=1000
# param= "ms" means that parameters are given via mean and standard deviation
## obtain posterior distributions
post_act <- postmix(weak_prior_treatment, m=y.act, se=y.act.se)
#postmix calculates the posterior distribution given a prior (here "weak_prior"),
#where the prior is a mixture of conjugate distributions.
#The posterior is then also a mixture of conjugate distributions.
post_control <- postmix(prior_control,m=y.pbo,se=y.pbo.se)
## calculate oddsratio and with that the estimated treatment effect
# Calculate Treatment effect and confidence interval by simulation of posterior mean
random_gen<-as.numeric(rmixdiff(post_act,post_control,n=1000))
#rmixdiff = random number generation for the difference of two mixture distributions
theta_hat<-mean(random_gen)
theta_ci<-quantile(random_gen,probs=c(alpha,1-alpha))
lower_ci <- as.numeric(theta_ci[1])
upper_ci <- as.numeric(theta_ci[2])
#Posterior probability
post_prob <- 1-pmixdiff(post_control,post_act,0)
return(list(p_val = post_prob,
treat_effect = theta_hat,
lower_ci = lower_ci,
upper_ci = upper_ci,
reject_h0 = (post_prob < alpha)))
}
MAP_rjags_cont(data = trial_data, arm = 3)
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran=TRUE, manual = TRUE)
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran=TRUE, manual = TRUE)
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran=TRUE, manual = TRUE)
devtools::build_manual(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL)
