trial_data <- datasim_cont(num_arms = 3,
n_arm = 3000,
d = c(0,3000,7500),
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta = c(0.25, 0, 0),
lambda = c(0.15, 0.15, 0.15, 0.15),
trend = "linear")
fixmodel_cal_cont(trial_data, arm=2, unit_size = 250)
fixmodel_cal_cont <- function(data, arm, alpha=0.025, unit_size=250){
data$cal_time <- rep(c(1:ceiling((nrow(data)/unit_size))), each=unit_size)[1:nrow(data)]
max_unit <- max(data[data$treatment==arm,]$cal_time)
data_new <- data[data$cal_time %in% c(1:max_unit),]
# fit linear model
if(max_unit==1){ # if only one calendar time unit in the data, don't use unit as covariate
mod <- lm(response ~ as.factor(treatment), data_new)
} else {
mod <- lm(response ~ as.factor(treatment) + as.factor(cal_time), data_new)
}
res <- summary(mod)
# one-sided p-value
p_val <- pt(coef(res)[paste0("as.factor(treatment)", arm), "t value"], mod$df, lower.tail = FALSE)
# metrics
treat_effect <- res$coefficients[paste0("as.factor(treatment)", arm), "Estimate"]
lower_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 1]
upper_ci <- confint(mod)[paste0("as.factor(treatment)", arm), 2]
reject_h0 <- (p_val < alpha)
return(list(p_val = p_val,
treat_effect = treat_effect,
lower_ci = lower_ci,
upper_ci = upper_ci,
reject_h0 = reject_h0))
}
trial_data <- datasim_cont(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
theta = rep(0.25, 3), lambda = rep(0.15, 4), sigma = 1, trend = "linear")
fixmodel_cal_cont(data = trial_data, arm = 3)
View(trial_data)
devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
#devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
library(NCC)
#devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
library(NCC)
?fixmodel_cal_cont
?mixmodel_cal_cont
library(tidyverse)
32*0.7
32*0.9
32*0.9
40*0.9
floor(40+0.99)
floor(40*0.99)
40*90
40*90/60
40*90/60/24
15*50
15*50/60
15*50/60/24
120/5
79+81
70-35
35/70
69*2
84*3
1-0.6382
4+6+6+3+3+3+6+3
45/7.4
library(NCC)
?datasim_cont
trial_data <- datasim_cont(num_arms = 10,
n_arm = 250,
d = 300*c(0:9),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 10),
lambda = rep(0.15, 11),
sigma = 1,
trend = "stepwise_2")
set.seed(1)
trial_data <- datasim_cont(num_arms = 10,
n_arm = 250,
d = 300*c(0:9),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 10),
lambda = rep(0.15, 11),
sigma = 1,
trend = "stepwise_2")
timemachine_cont(data = trial_data, arm = 3)
View(trial_data)
trial_data <- datasim_cont(num_arms = 3,
n_arm = 250,
d = rep(0, 3),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "stepwise_2")
MAP_rjags_cont(data = trial_data, arm = 2)
timemachine_cont(data = trial_data_2, arm = 3)
trial_data_2 <- datasim_cont(num_arms = 3,
n_arm = 250,
d = rep(0, 3),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "stepwise_2")
trial_data_1 <- datasim_cont(num_arms = 10,
n_arm = 250,
d = 300*c(0:9),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 10),
lambda = rep(0.15, 11),
sigma = 1,
trend = "stepwise_2")
timemachine_cont(data = trial_data_2, arm = 3)
rm(trial_data)
set.seed(1)
trial_data_1 <- datasim_cont(num_arms = 10,
n_arm = 250,
d = 300*c(0:9),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 10),
lambda = rep(0.15, 11),
sigma = 1,
trend = "stepwise_2")
timemachine_cont(data = trial_data_1, arm = 3)
trial_data_2 <- datasim_cont(num_arms = 3,
n_arm = 250,
d = rep(0, 3),
period_blocks = 2,
mu0 = 0,
theta = rep(0, 3),
lambda = rep(0.15, 4),
sigma = 1,
trend = "stepwise_2")
MAP_rjags_cont(data = trial_data_2, arm = 2)
MAP_rjags_cont(data = trial_data_2, arm = 3)
devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
NCC::sepmodel_adj_cont()
?NCC::sepmodel_adj_cont
devtools::install_github("pavlakrotka/NCC@v1.0", build = TRUE, force=T)
install.packages("gmp")
23-7.5
35-23-7.5
35-23
42-35
version
25-13
12*360
12*360/60
12*360/60/24
250*c(0,1,1,2,2,3,3)
43+58+51+66+55+45+47+14+56+22+49+37+69+20+71+33+57+38+57+32+37+34
1-0.896
1-0.774
1-0.655
1-0.916
1-0.664
1-0.47
1-0.938
1-0.752
1-0.656
devtools::install_github("pavlakrotka/NCC", build = TRUE, force=T)
library(NCC)
library(tidyverse)
scenario_iii_eq_alpha <- data.frame(num_arms = 4,
n_arm = 250,
d1 = 250*0,
d2 = 250*1,
d3 = 250*2,
d4 = 250*3,
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta1 = 0,
theta2 = 0,
theta3 = 0,
theta4 = 0,
lambda0 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda1 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda2 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda3 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda4 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
trend = c(rep("linear", 27), rep("stepwise_2", 27), rep("stepwise",27), rep("inv_u", 27), rep("seasonal", 27*2)),
alpha = 0.025,
ncc = TRUE,
unit_size = 25,
ci = FALSE,
bs_degree = c(1,2,3),
poly_degree = c(1,2,3),
n_wave = c(rep(NA, 27*4), rep(1, 27), rep(2, 27)),
N_peak = 750) %>%
mutate(timetrend = ifelse(lambda0==lambda1 & lambda1==lambda2 & lambda1==lambda3, "EQ", "DIFF"),
hypothesis = ifelse(theta2==0 & theta3==0, "H0", "H1"))
sim_study_par(nsim = 3, scenarios = scenario_iii_eq_alpha[c(1,2,3),], models = c("splines", "splines_cal", "fixmodel", "fixmodel_cal", "mixmodel", "mixmodel_cal", "mixmodel_AR1", "mixmodel_AR1_cal", "piecewise", "piecewise_cal", "sepmodel", "poolmodel"), endpoint = "cont", perc_cores = 0.99)
library(NCC)
as.integer(3)
as.integer(3.4)
datasim_bin(num_arms = 3, n_arm = 100, d = c(0, 100, 250), p0 = 0.7, OR = rep(1.8, 3), lambda = rep(0.15, 4), trend="ahoj")
datasim_bin(num_arms = 3, n_arm = 100, d = c(0, 100, 250), p0 = 0.7, OR = rep(1.8, 3), lambda = rep(0.15, 4))
datasim_bin(num_arms = c(3, 1), n_arm = 100, d = c(0, 100, 250), p0 = 0.7, OR = rep(1.8, 3), lambda = rep(0.15, 4), trend="linear")
datasim_bin(num_arms = 3, n_arm = 100, d = c(0, 100, 250), p0 = 0.7, OR = rep(1.8, 6), lambda = rep(0.15, 4), trend="linear")
datasim_bin(num_arms = 3, n_arm = 100, d = c(0, 100, 250), p0 = 0.7, OR = rep(1.8, 3), lambda = rep(0.15, 4), trend="inv_u")
is.numeric(c(1,2,3))
models = c("fixmodel", "sepmodel", "ahoj")
models %in% c("fixmodel", "mixmodel", "mixmodel_AR1", "inv_u", "seasonal")
if((models %in% c("fixmodel", "mixmodel", "mixmodel_AR1", "inv_u", "seasonal")==FALSE){
print("Time trend pattern (`trend`) must be one of the following strings: 'linear', 'stepwise', 'stepwise_2', 'inv_u', 'seasonal'!")
}
print(paste0("Starting the simulations. ", dim(scenarios)[1], " scenarios will be simulated. Starting time: ", Sys.time()))
cores <- detectCores()
cl <- makeCluster(floor(cores[1]*perc_cores)) # not to overload your computer
registerDoParallel(cl)
if (endpoint=="bin") {
models <- models[models!="mixmodel"] # not implemented yet
}
models <- sort(models)
if(endpoint=="cont"){
result <- NULL
num_models <- length(models)
for(i in 1:dim(scenarios)[1]){
if(missing(arms)){
arms <- c(2:scenarios[i,]$num_arms)
}
arms <- sort(arms)
d_i <- as.numeric(scenarios[i, grepl("^d\\d", names(scenarios))])
theta_i <- as.numeric(scenarios[i, grepl("^theta\\d", names(scenarios))])
lambda_i <- as.numeric(scenarios[i, grepl("^lambda\\d", names(scenarios))])
time_dep_effect_i <- datasim_cont(n_arm = scenarios$n_arm[i],
num_arms = scenarios$num_arms[i],
d = d_i,
period_blocks = scenarios$period_blocks[i],
mu0 = scenarios$mu0[i],
theta = theta_i,
lambda = lambda_i,
sigma = scenarios$sigma[i],
trend = scenarios$trend[i],
N_peak = scenarios$N_peak[i],
n_wave = scenarios$n_wave[i],
full = TRUE,
check = FALSE)$time_dep_effect
db <- foreach(icount(nsim), .combine = cbind,
.packages = c("NCC")) %dopar% {
all_models(data = datasim_cont(n_arm = scenarios$n_arm[i],
num_arms = scenarios$num_arms[i],
d = d_i,
period_blocks = scenarios$period_blocks[i],
mu0 = scenarios$mu0[i],
theta = theta_i,
lambda = lambda_i,
sigma = scenarios$sigma[i],
trend = scenarios$trend[i],
N_peak = scenarios$N_peak[i],
n_wave = scenarios$n_wave[i],
full = FALSE,
check = FALSE),
arms = arms,
models = models,
endpoint = endpoint,
alpha = scenarios$alpha[i],
unit_size = scenarios$unit_size[i],
ncc = scenarios$ncc[i],
opt = scenarios$opt[i],
prior_prec_tau = scenarios$prior_prec_tau[i],
n.samples = scenarios$n.samples[i],
n.chains = scenarios$n.chains[i],
n.iter = scenarios$n.iter[i],
n.adapt = scenarios$n.adapt[i],
robustify = scenarios$robustify[i],
weight = scenarios$weight[i],
ci = scenarios$ci[i],
prec_delta = scenarios$prec_delta[i],
prec_gamma = scenarios$prec_gamma[i],
tau_a = scenarios$tau_a[i],
tau_b = scenarios$tau_b[i],
prec_a = scenarios$prec_a[i],
prec_b = scenarios$prec_b[i],
bucket_size = scenarios$bucket_size[i],
smoothing_basis = scenarios$smoothing_basis[i],
basis_dim = scenarios$basis_dim[i],
gam_method = scenarios$gam_method[i],
bs_degree = scenarios$bs_degree[i],
poly_degree = scenarios$poly_degree[i])
}
result_i <- cbind(scenarios[i,],
study_arm = rep(arms, each = num_models),
model = models,
reject_h0 = rowMeans(matrix(as.logical(unlist(unname(db[grep("reject_h0_", rownames(db)),]))), ncol = nsim), na.rm = TRUE), # get power/T1E
bias = rowMeans(matrix(as.double(unlist(unname(db[grep("treat_effect", rownames(db)),]))), ncol = nsim)-time_dep_effect_i[arms], na.rm = TRUE), # get bias (using time dependent treatment effect)
MSE = rowMeans((matrix(as.double(unlist(unname(db[grep("treat_effect", rownames(db)),]))), ncol = nsim)-time_dep_effect_i[arms])^2, na.rm = TRUE), # get MSE (using time dependent treatment effect)
failed = rowSums(is.na(matrix(as.logical(unlist(unname(db[grep("reject_h0_", rownames(db)),]))), ncol = nsim))),
nsim = nsim,
row.names = NULL)
result <- rbind(result, result_i)
print(paste0("Scenario ", i, "/", dim(scenarios)[1], " done. Time: ", Sys.time()))
}
stopCluster(cl)
gc()
}
if(endpoint=="bin"){
result <- NULL
num_models <- length(models)
for(i in 1:dim(scenarios)[1]){
if(missing(arms)){
arms <- c(2:scenarios[i,]$num_arms)
}
arms <- sort(arms)
d_i <- as.numeric(scenarios[i, grepl("^d\\d", names(scenarios))])
OR_i <- as.numeric(scenarios[i, grepl("^OR\\d", names(scenarios))])
lambda_i <- as.numeric(scenarios[i, grepl("^lambda\\d", names(scenarios))])
time_dep_effect_i <- datasim_bin(n_arm = scenarios$n_arm[i],
num_arms = scenarios$num_arms[i],
d = d_i,
period_blocks = scenarios$period_blocks[i],
p0 = scenarios$p0[i],
OR = OR_i,
lambda = lambda_i,
trend = scenarios$trend[i],
N_peak = scenarios$N_peak[i],
n_wave = scenarios$n_wave[i],
full = TRUE,
check = FALSE)$time_dep_effect
db <- foreach(icount(nsim), .combine = cbind,
.packages = c("NCC")) %dopar% {
all_models(data = datasim_bin(n_arm = scenarios$n_arm[i],
num_arms = scenarios$num_arms[i],
d = d_i,
period_blocks = scenarios$period_blocks[i],
p0 = scenarios$p0[i],
OR = OR_i,
lambda = lambda_i,
trend = scenarios$trend[i],
N_peak = scenarios$N_peak[i],
n_wave = scenarios$n_wave[i],
full = FALSE,
check = FALSE),
arms = arms,
models = models,
endpoint = endpoint,
alpha = scenarios$alpha[i],
unit_size = scenarios$unit_size[i],
ncc = scenarios$ncc[i],
opt = scenarios$opt[i],
prior_prec_tau = scenarios$prior_prec_tau[i],
n.samples = scenarios$n.samples[i],
n.chains = scenarios$n.chains[i],
n.iter = scenarios$n.iter[i],
n.adapt = scenarios$n.adapt[i],
robustify = scenarios$robustify[i],
weight = scenarios$weight[i],
ci = scenarios$ci[i],
prec_delta = scenarios$prec_delta[i],
prec_gamma = scenarios$prec_gamma[i],
tau_a = scenarios$tau_a[i],
tau_b = scenarios$tau_b[i],
prec_a = scenarios$prec_a[i],
prec_b = scenarios$prec_b[i],
bucket_size = scenarios$bucket_size[i],
smoothing_basis = scenarios$smoothing_basis[i],
basis_dim = scenarios$basis_dim[i],
gam_method = scenarios$gam_method[i],
bs_degree = scenarios$bs_degree[i],
poly_degree = scenarios$poly_degree[i])
}
result_i <- cbind(scenarios[i,],
study_arm = rep(arms, each = num_models),
model = models,
reject_h0 = rowMeans(matrix(as.logical(unlist(unname(db[grep("reject_h0_", rownames(db)),]))), ncol = nsim), na.rm = TRUE), # get power/T1E
bias = rowMeans(matrix(as.double(unlist(unname(db[grep("treat_effect", rownames(db)),]))), ncol = nsim)-log(time_dep_effect_i[arms]), na.rm = TRUE), # get bias (using time dependent treatment effect)
MSE = rowMeans((matrix(as.double(unlist(unname(db[grep("treat_effect", rownames(db)),]))), ncol = nsim)-log(time_dep_effect_i[arms]))^2, na.rm = TRUE), # get MSE (using time dependent treatment effect)
failed = rowSums(is.na(matrix(as.logical(unlist(unname(db[grep("reject_h0_", rownames(db)),]))), ncol = nsim))),
nsim = nsim,
row.names = NULL)
result <- rbind(result, result_i)
print(paste0("Scenario ", i, "/", dim(scenarios)[1], " done. Time: ", Sys.time()))
}
stopCluster(cl)
gc()
}
return(result)
}
if((models %in% c("fixmodel", "mixmodel", "mixmodel_AR1", "inv_u", "seasonal")==FALSE){
print("Time trend pattern (`trend`) must be one of the following strings: 'linear', 'stepwise', 'stepwise_2', 'inv_u', 'seasonal'!")
}
if((models %in% c("fixmodel", "mixmodel", "mixmodel_AR1", "inv_u", "seasonal")==FALSE)){
print("Time trend pattern (`trend`) must be one of the following strings: 'linear', 'stepwise', 'stepwise_2', 'inv_u', 'seasonal'!")
}
models %in% c("fixmodel", "mixmodel", "mixmodel_AR1", "inv_u", "seasonal")==FALSE)>0
sum(models %in% c("fixmodel", "mixmodel", "mixmodel_AR1", "inv_u", "seasonal")==FALSE)
if(sum(models %in% c("fixmodel", "mixmodel", "mixmodel_AR1", "inv_u", "seasonal")==FALSE)>0){
print("Time trend pattern (`trend`) must be one of the following strings: 'linear', 'stepwise', 'stepwise_2', 'inv_u', 'seasonal'!")
}
datasim_bin(num_arms = 3, n_arm = 100, d = c(0, 100, 250), p0 = 0.7, OR = rep(1.8, 6), lambda = rep(0.15, 4), trend="linear")
datasim_bin(num_arms = 3, n_arm = 100, d = c(0, 100, 250), p0 = 0.7, OR = rep(1.8, 3), lambda = rep(0.15, 4), trend=c("linear", "stepwise"))
perc_cores>=1
0.9>=1
0.9<=0
library(tidyverse)
scenarios <- data.frame(num_arms = 4,
n_arm = 250,
d1 = 250*0,
d2 = 250*1,
d3 = 250*2,
d4 = 250*3,
period_blocks = 2,
mu0 = 0,
sigma = 1,
theta1 = 0,
theta2 = 0,
theta3 = 0,
theta4 = 0,
lambda0 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda1 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda2 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda3 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
lambda4 = rep(seq(-0.5, 0.5, length.out = 9), each=3),
trend = c(rep("linear", 27), rep("stepwise_2", 27), rep("stepwise",27), rep("inv_u", 27), rep("seasonal", 27*2)),
alpha = 0.025,
ncc = TRUE,
unit_size = 25,
ci = FALSE,
bs_degree = c(1,2,3),
poly_degree = c(1,2,3),
n_wave = c(rep(NA, 27*4), rep(1, 27), rep(2, 27)),
N_peak = 750) %>%
mutate(timetrend = ifelse(lambda0==lambda1 & lambda1==lambda2 & lambda1==lambda3, "EQ", "DIFF"),
hypothesis = ifelse(theta2==0 & theta3==0, "H0", "H1"))
as.numeric(scenarios[i, grepl("^d\\d", names(scenarios))])
i=1
as.numeric(scenarios[i, grepl("^d\\d", names(scenarios))])
2:scenarios[i,]$num_arms
as.numeric(scenarios[i, grepl("^d\\d", names(scenarios))])[1:scenarios[i,]$num_arms]
as.numeric(scenarios[i, grepl("^theta\\d", names(scenarios))])[1:scenarios[i,]$num_arms]
as.numeric(scenarios[i, grepl("^theta\\d", names(scenarios))])
as.numeric(scenarios[i, grepl("^lambda\\d", names(scenarios))])[1:scenarios[i,]$num_arms]
as.numeric(scenarios[i, grepl("^lambda\\d", names(scenarios))])
[1:(scenarios[i,]$num_arms+1)]
1:(scenarios[i,]$num_arms+1)
as.numeric(scenarios[i, grepl("^lambda\\d", names(scenarios))])[1:(scenarios[i,]$num_arms+1)]
colnames(scenarios)
trial_data <- datasim_bin(num_arms = 3, n_arm = 100, d = c(0, 100, 250),
p0 = 0.7, OR = rep(1.8, 3), lambda = rep(0.15, 4), trend="stepwise")
c("treatment", "respose") %in% colnames(trial_data)
c("treatment", "response") %in% colnames(trial_data)
View(trial_data)
c("treatment", "response", "period") %in% colnames(trial_data)
c("treatment", "response", "period") %in% colnames(trial_data)!=3
sum(c("treatment", "response", "period") %in% colnames(trial_data))!=3
is.data.frame(trial_data)
is.logical(TRUE)
is.logical(FALSE)
library(mgsv)
library(mgcv)
?s
?gam
# Copy in R folder the functions of the r package
setwd("C:/Users/pavla/Nextcloud/GitKraken/NCC")
# Run once to configure your package to use pkgdown
usethis::use_pkgdown()
# Run to build the website
pkgdown::build_site()
?usethis::use_pkgdown
# Run once to configure your package to use pkgdown
usethis::use_pkgdown()
# Run to build the website
pkgdown::build_site()
# Create r package folder
usethis::create_package("C:/Users/pavla/Nextcloud/GitKraken/NCC")
# Copy in R folder the functions of the r package
setwd("C:/Users/pavla/Nextcloud/GitKraken/NCC")
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran = TRUE, manual = TRUE)
devtools::build_manual(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL)
# Run once to configure your package to use pkgdown
usethis::use_pkgdown()
# Run to build the website
pkgdown::build_site()
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran = TRUE, manual = TRUE)
devtools::document()
devtools::load_all()
# Copy in R folder the functions of the r package
setwd("C:/Users/pavla/Nextcloud/GitKraken/NCC")
Sys.setenv("_R_CHECK_SYSTEM_CLOCK_" = 0)
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran = TRUE, manual = TRUE)
devtools::document()
devtools::load_all()
# Build & check the package
devtools::build(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL, binary = FALSE, manual = TRUE, vignettes = TRUE)
devtools::check_built(path = "C:/Users/pavla/Nextcloud/GitKraken/NCC", cran = TRUE, manual = TRUE)
devtools::build_manual(pkg = "C:/Users/pavla/Nextcloud/GitKraken/NCC", path = NULL)
# Run once to configure your package to use pkgdown
usethis::use_pkgdown()
# Run to build the website
pkgdown::build_site()
